+------------------------------------------------------------------------------+
| INTERRUPTS for ARMv8                                                         |
+------------------------------------------------------------------------------+

An interrupt is a signal to the processor that an event has occurred which needs
to be dealt with. Interrupts are typically generated by peripherals.

--------------------------------------------------------------------------------

AArch64 Exception Registers

@Exception Link Register
ELR_ELx Holds the address of the instruction which caused the exception

@Exception Syndrome Register
ESR_ELx Includes information about the reasons for the exception

@Fault Address Register
FAR_ELx Holds the virtual faulting address

@Hypervisor Configuration Register
HCR_ELx Controls virtualization settings and trapping of exceptions to EL2

@Secure Configuration Register
SCR_ELx Controls Secure state and trapping of exceptions to EL3

@System Control Register
SCTLR_ELx Controls standard memory, system facilities, and provides status
information for implemented functions

@Saved Program Status Register
SPSR_ELx Holds the saved processor state when an exception is taken to this ELx

@Vector Base Address Register
VBAR_ELx Holds the exception base address for any exception that is taken to ELx

--------------------------------------------------------------------------------

Execution states - AArch32/AArch64

*---------*     (interprocessing)      *---------*
| AArch64 | -------------------------> | AArch32 |
*---------*                            *---------*

When an exception is taken, the processor may change execution state (from
AArch64 to AArch32) or stay in the same execution state.

Security states - secure state/non-secure state (FOR most Cortex-A)

The Security state defines which of the implemented Exception levels can be
accessed, which areas of memory can currently be accessed, and how those
accesses are represented on the system memory bus.

In Armv8-A EL3 is always in Secure state. In Armv9-A, EL3 is part of Secure
state unless RME is implemented. If RME is implemented, Root state is a
separation of EL3 from the rest of Secure state.

1) synchronous exceptions
    • Invalid instructions and trap exceptions (Instruction Abort)
    • Memory accesses (Data Abort)
    • Exception-generating instructions
        SVC - Supervisor Call
        HVC - Hypervisor Call
        SMC - Secure Monitor Call
    • Debug exceptions
		Breakpoint Instruction exceptions
		Breakpoint exceptions
		Watchpoint exceptions
		Vector Catch exceptions
		Software Step exceptions

2) Asynchronous exceptions
    • Physical interrupts
        • SError
        • IRQ
        • FIQ
    • Virtual interrupts
        • vSError
        • vIRQ
        • vFIQ

The Exception Syndrome Register, ESR_ELn, contains information which allows the
exception handler to determine the reason for the exception. It is updated only
for synchronous exceptions and SError. It is not updated for IRQ or FIQ as these
interrupt handlers typically obtain status information from registers in the
Generic Interrupt Controller (GIC).

The Arm architecture has two asynchronous exception types, IRQ and FIQ, that are
intended to be used to support handling of peripheral interrupts.

Asynchronous exceptions can be temporarily masked and left in a pending state
until the exception is unmasked and taken.
(Tip: both physical and virtual asynchronous exceptions can be temporarily
masked.)

*-------------*        GIC         *---------------------*
| Peripherals | -----------------> | Physical Interrupts |
*-------------*                    *---------------------*

--------------------------------------------------------------------------------

Virtual interrupts (can be seen by VMs)
    • vSError, Virtual System Error
    • vIRQ, Virtual IRQ
    • vFIQ, Virtual FIQ

Virtual interrupts can be generated either from a hypervisor at EL2 or by using
an interrupt controller. The hypervisor must set the corresponding routing bit
in the Hypervisor Conﬁguration Register (HCR_EL2).

HCR_EL2.VSE -> Setting the bit registers a vSError
HCR_EL2.VI  -> Setting the bit registers a vIRQ
HCR_EL2.VF  -> Setting the bit registers a vFIQ

--------------------------------------------------------------------------------

In AArch64, interrupts are a specific type of externally generated exception.

@Program Flow in EL0
          |                   Exception Vector Table (VBAR_ELx)
          |                             /
          v       PC -> ELR_EL1        /
          +-------------------------->+
                PSTATE -> SPSR_EL1    |
                                      |
                                      +- Exception Handler
                                      |
                  ELR_EL1 -> PC       |
          +<--------------------------+
          |     SPSR_EL1 -> PSTATE
          |
          v
     [continue]

Saved Program Status Register (SPSR)
	• Condition flags
	• Execution state controls
	• Exception mask bits
	• Access control bits
	• Timing control bits
	• Speculation control bits

Exception mask bits (DAIF) in PSTATE allow exception events to be masked:
    • D - Debug exception mask bit
    • A - SError asynchronous exception mask bit
    • I - IRQ asynchronous exception mask bit
    • F - FIQ asynchronous exception mask bit

For synchronous exceptions and SErrors, the Exception Syndrome Register(ESR) is
also updated.

Each Exception level has its own vector table, with the base address defined by
its own Vector Base Address Register, VBAR_EL<x>, where <x> is 1,2, or 3.

Routing is conﬁgured using the Secure Conﬁguration Register SCR_EL3 and the
Hypervisor Conﬁguration Register HCR_EL2. The SCR_EL3 register speciﬁes which
exceptions are routed to EL3, while the HCR_EL2 register similarly speciﬁes
which exceptions are routed to EL2.

        Exceptions
             |
HCR_EL2 >>---+---> EL2

        Exceptions
             |
SCR_EL3 >>---+---> EL3

--------------------------------------------------------------------------------

Generic Interrupt Controller (GIC)

The GIC performs the critical tasks of interrupt management, prioritization,
and routing. The GIC marshals all interrupts from across the system, prioritizes
them, and sends them to a core to be dealt with. GICs are primarily used to
boost processor efficiency and to enable interrupt virtualization.

[Interrupt Sources] each of them with a unique interrupt ID.
  |  |   ... |
  v  v       v      High
 +-------------+  Priority   +---------------+     IAR     +------------+
 | Distributor | ----------> | CPU Interface | ----------> | CPU core X |
 +-------------+             +---------------+    irqID    +------------+
                                     |                            |
                                     |                            v
                                     |        Device-specific Interrupt Handler
                                     |                            |
                                     |            EoI             v
                                     +<---------------------------+

Types of Interrupts:
	• Software Generated Interrupt (SGI)
	• Private Peripheral Interrupt (PPI)
	• Shared Peripheral Interrupt  (SPI)
	• Locality-specific Peripheral Interrupt (LPI)

Interrupts can either be edge-triggered or level-sensitive.
                             |                   |
        When GIC detects [rising edge] or [high voltage level]

Interrupts can be in different states:
	Inactive
	Pending
	Active
	Active and pending

--------------------------------------------------------------------------------

Interrupt Handling

The priority and list of cores to which an interrupt can be delivered to are
all configured in the Distributor. An interrupt asserted to the Distributor by
a peripheral is in the Pending state (or Active and Pending if it was already
Active).

The Distributor determines the highest priority pending interrupt that can be
delivered to a core and forwards that to the CPU interface of the core. At the
CPU interface, the interrupt is in turn signaled to the core, at which point
the core takes the FIQ or IRQ exception.

When the core takes an interrupt, it jumps to the top-level interrupt vector
obtained from the vector table and begins execution.
The top-level interrupt handler reads the Interrupt Acknowledge Register (IAR)
from the CPU Interface block to obtain the interrupt ID.

As well as returning the interrupt ID, the read causes the interrupt to be
marked as active in the Distributor. Once the interrupt ID is known (identifying
the interrupt source), the top-level handler can now dispatch a device-specific
handler to service the interrupt.

When the device-specific handler finishes execution, the top-level handler
writes the same interrupt ID to the End of Interrupt (EoI) register in the CPU
Interface block, indicating the end of interrupt processing.

                          INTERRUPT
                              |
                              ▼
                *----------------------------*
                | Perform time critical work |
Top Halves      |   (Interrupts disabled)    |
                +----------------------------+
                              |
                              ▼
                *----------------------------*
Bottom Halves   |   Perform remaining work   |
                |    (Interrupts disabled)   |
                *----------------------------*

@Defer bottom halves for executing at a later time.

--------------------------------------------------------------------------------

Reference:
[1] Learn the architecture - AArch64 Exception Model
[2] ARM Cortex-A Series Programmer’s Guide for ARMv8-A

--------------------------------------------------------------------------------
Reference to Linux-6.1.63

=> arch/arm64/kernel/entry.S

	.pushsection ".entry.text", "ax"

	.align	11
SYM_CODE_START(vectors)
kernel_ventry	1, t, 64, sync		=> Synchronous EL1t ------+
kernel_ventry	1, t, 64, irq		=> IRQ EL1t               |
kernel_ventry	1, t, 64, fiq		=> FIQ EL1t               | UNHANDLED
kernel_ventry	1, t, 64, error		=> Error EL1t ------------+

kernel_ventry	1, h, 64, sync		=> Synchronous EL1h
kernel_ventry	1, h, 64, irq		=> IRQ EL1h
kernel_ventry	1, h, 64, fiq		=> FIQ EL1h
kernel_ventry	1, h, 64, error		=> Error EL1h

kernel_ventry	0, t, 64, sync		=> Synchronous 64-bit EL0
kernel_ventry	0, t, 64, irq		=> IRQ 64-bit EL0
kernel_ventry	0, t, 64, fiq		=> FIQ 64-bit EL0
kernel_ventry	0, t, 64, error		=> Error 64-bit EL0

kernel_ventry	0, t, 32, sync		=> Synchronous 32-bit EL0
kernel_ventry	0, t, 32, irq		=> IRQ 32-bit EL0
kernel_ventry	0, t, 32, fiq		=> FIQ 32-bit EL0
kernel_ventry	0, t, 32, error		=> Error 32-bit EL0
SYM_CODE_END(vectors)

=> arch/arm64/kernel/entry-common.c

--------------------------------------------------------------------------------

el1h_64_irq_handler()
        |
        +- el1_interrupt()

el1h_64_fiq_handler()
        |
        +- with handler callback [void (*handle_arch_irq/fiq)()]
           el1_interrupt()
              |
              +- if CONFIG_ARM64_PSEUDO_NMI enabled and not interrupt_enabled()
                        |no		              |yes
                        +- __el1_irq()		      +- __el1_pnmi()
                               :                              :
                               +--> do_interrupt_handler() <--+
                                        |
                                        :
                                        +- if on_thread_stack() -> [1]
                                                |yes
                                                +- call_on_irq_stack()
                                                   [+] arch/arm64/kernel/entry.S

   [1]
    |no
 handler() callback registered
    |
    +-> 1) handle_arch_irq <-- set_handle_irq() to set the irq handlers
        2) hanele_arch_fiq <-- set_handle_fiq() to set the fiq handlers

el1h_64_error_handler()
        |
        +- do_serror()

--------------------------------------------------------------------------------

el0t_64_irq_handler()
        |
        +- __el0_irq_handler_common() ----->+
                                            |
el0t_64_fiq_handler()                       |
        |                                   |
        +- __el0_fiq_handler_common() ----->+
                                            |
                                            +- el0_interrupt()
                                                      |
                                                      :
                                                      +- do_interrupt_handler()

el0t_64_error_handler()
        |
        +- __el0_error_handler_common()
                          |
                          :
                          +- do_serror() @arch/arm64/kernel/traps.c
                                |
                                +- if !arm64_is_ras_serror(esr) or
                                      arm64_is_fatal_ras_serror(regs, esr)
                                              |yes
                                              +- arm64_serror_panic(regs, esr)

--------------------------------------------------------------------------------
- Linux generic IRQ handling -

*-------------------------------------------------------------------------*
| There are three main levels of abstraction in the Linux interrupt code: |
| a) High-level driver API                                                |
| b) High-level IRQ flow handlers                                         |
| c) Chip-level hardware encapsulation                                    |
*-------------------------------------------------------------------------*

@arch/arm64/kernel/irq.c

init_IRQ()
    |
    +- init_irq_stacks()
    |
    +- init_irq_scs()
    |
    +- irqchip_init()
    :        |
             +- of_irq_init(__irqchip_of_table) [+] drivers/irqchip/irqchip.c
             :  To scan and init matching interrupt controllers in DT
                     :
                     +-> (struct of_intc_desc *) desc->irq_init_cb
                                                           |
Note that GIC, GICv2, GICv3, GICv4, etc.                   |
have different initialization processes.                   |
                                                           v
gic_of_init() <--------------------------------------------+ IRQCHIP_DECLARE()
    |
    :
    +- __gic_init_bases()
               |
               :
               +- if gic == &gic_data[0]
                           :
                           +- set_handle_irq(gic_handle_irq)
               :
               +- gic_init_bases()
               |
               +- if gic == &gic_data[0]
                           |
                           +- gic_smp_init()
                                    :
                                    +- base_sgi = __irq_domain_alloc_irqs()
                                    :
                                    +- set_smp_ipi_range()
                                               |
                                               +- request_percpu_irq()
                                                            |
                                             +----------------------------+
                                             | Request NR_IPI of IPI irqs |
                                             | with ipi_handler()         |
                                             +----------------------------+

IPI (Inter-Processor Interrupt)

ipi_handler() <--------------------- action->handler()
      |
      +- do_handle_IPI()

[+] arch/arm64/kernel/smp.c

enum ipi_msg_type {
	IPI_RESCHEDULE,     ----> scheduler_ipi() [+] include/linux/sched.h
	IPI_CALL_FUNC,      ----> generic_smp_call_function_interrupt()
	IPI_CPU_STOP,
	IPI_CPU_CRASH_STOP,
	IPI_TIMER,
	IPI_IRQ_WORK,       ----> irq_work_run() [+] kernel/irq_work.c
	IPI_WAKEUP,
	NR_IPI
};

--------------------------------------------------------------------------------
$ cat /proc/interrupts

IPI0:      6474       8148       7791 ... Rescheduling interrupts
IPI1:    314876     319197     853535 ... Function call interrupts
IPI2:         0          0          0 ... CPU stop interrupts
IPI3:         0          0          0 ... CPU stop (for crash dump) interrupts
IPI4:         0          0          0 ... Timer broadcast interrupts
IPI5:     20319       4925       3830 ... IRQ work interrupts
IPI6:         0          0          0 ... CPU wake-up interrupts

--------------------------------------------------------------------------------

Note that normally, gic_handle_irq() is set as root IRQ handler.

gic_handle_irq()
    |
    :
    +- generic_handle_domain_irq()
                |
                :   irq_resolve_mapping(domain, hwirq)
                |                 |irq_desc
                +- handle_irq_desc()
                        |
                        :
                        +- generic_handle_irq_desc()
                                |
                                +- desc->handle_irq(desc)
                                                |
                                                +-> highlevel irq-events handler
                                                                |
                +<----------------------------------------------+
                |
The interrupt flow handlers (either pre-defined or architecture specific) are
assigned to specific interrupts by the architecture either during bootup or
during device initialization.

- handle_level_irq()
- handle_fasteoi_irq()
- handle_edge_irq()  --- *** ---> action->handler()
- handle_edge_eoi_irq()                      |
- handle_simple_irq()                       [x]
- handle_untracked_irq()
- handle_percpu_irq()
- handle_percpu_devid_irq()
- handle_bad_irq()
- handle_nested_irq()
- handle_fasteoi_nmi()
- handle_percpu_devid_fasteoi_nmi()

struct irqaction {
	irq_handler_t		handler;
	void			*dev_id;
	...
	irq_handler_t		thread_fn;
	struct task_struct	*thread;
	...
} ____cacheline_internodealigned_in_smp;

handle_level_irq()
        |
        :
        +- handle_irq_event()
                :
                +- handle_irq_event_percpu()
                        :
                        +- __handle_irq_event_percpu()
                                |
                                :
                                +- res = action->handler(irq, action->dev_id)
                                :
                                +- if res == IRQ_WAKE_THREAD
                                        :
                                        +- __irq_wake_thread()
                                             :
                                             +- wake_up_process(action->thread)

To allocates interrupt resources and enables the interrupt line and IRQ
handling:

request_threaded_irq()                                                [x]
        |                                                              |
        : @corresponding irqaction initialization {action->handler = handler}
        |
        +- irq_chip_pm_get()
        |
        +- __setup_irq()
                |
                :
                +- setup_irq_thread()
                           : @creates kernel threads which can be seen: irq/*
                           +- new->thread = get_task_struct(t)

@action->handler is still called in hard interrupt context and has to check
whether the interrupt originates from the device. If yes it needs to disable
the interrupt on the device and return IRQ_WAKE_THREAD which will wake up the
handler thread and run.

@action->thread_fn. This split handler design is necessary to support shared
interrupts.

--------------------------------------------------------------------------------
- IRQDOMAIN -

The irq_domain library adds mapping between hwirq and IRQ numbers on top of the
irq_alloc_desc*() API.

|-------------------- irq_resolve_mapping() --------------------->|

                        irqdomain
Hardware Interrupt ID -------------> IRQ number -------------> irq_desc
                                                                  |
       +<---------------------------------------------------------+
       |
early_irq_init() initializes the interrupt descriptors.
       |
       +- With CONFIG_SPARSE_IRQ enabled, use radix tree
       |  to manage the irq_desc (for irqdomain use)
       :
       +- arch_early_irq_init()

--------------------------------------------------------------------------------

start_kernel()
     |
     :
     +- early_irq_init()
     |
     +- init_IRQ()
     :
     +- softirq_init()
     :        |
              +-> Based on *tasklet*

- HI_SOFTIRQ
- TIMER_SOFTIRQ
- NET_TX_SOFTIRQ
- NET_RX_SOFTIRQ
- BLOCK_SOFTIRQ
- IRQ_POLL_SOFTIRQ
- TASKLET_SOFTIRQ
- SCHED_SOFTIRQ
- HRTIMER_SOFTIRQ
- RCU_SOFTIRQ

--------------------------------------------------------------------------------

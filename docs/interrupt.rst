+--------------------------------------------------------------------------------------+
| INTERRUPTS for ARMv8                                                                 |
+--------------------------------------------------------------------------------------+

An interrupt is a signal to the processor that an event has occurred which needs to be
dealt with. Interrupts are typically generated by peripherals.

----------------------------------------------------------------------------------------

AArch64 Exception Registers

Exception Link Register
    ELR_ELx Holds the address of the instruction which caused the exception
Exception Syndrome Register
    ESR_ELx Includes information about the reasons for the exception
Fault Address Register
    FAR_ELx Holds the virtual faulting address
Hypervisor Configuration Register
    HCR_ELx Controls virtualization settings and trapping of exceptions to EL2
Secure Configuration Register
    SCR_ELx Controls Secure state and trapping of exceptions to EL3
System Control Register
    SCTLR_ELx Controls standard memory, system facilities, and provides status
    information for implemented functions
Saved Program Status Register
    SPSR_ELx Holds the saved processor state when an exception is taken to this ELx
Vector Base Address Register
    VBAR_ELx Holds the exception base address for any exception that is taken to ELx
----------------------------------------------------------------------------------------

Execuation states - AArch32/AArch64

+---------+     (interprocessing)      +---------+
| AArch64 | -------------------------> | AArch32 |
+---------+                            +---------+

When an exception is taken, the processor may change execution state (from AArch64 to
AArch32) or stay in the same execution state.

Security states - secure state/non-secure state (FOR most Cortex-A)

The Security state defines which of the implemented Exception levels can be accessed,
which areas of memory can currently be accessed, and how those accesses are represented
on the system memory bus.

In Armv8-A EL3 is always in Secure state. In Armv9-A, EL3 is part of Secure state unless
RME is implemented. If RME is implemented, Root state is a separation of EL3 from the
rest of Secure state.

1) synchronous exceptions
    • Invalid instructions and trap exceptions (Instruction Abort)
    • Memory accesses (Data Abort)
    • Exception-generating instructions
        SVC - Supervisor Call
        HVC - Hypervisor Call
        SMC - Secure Monitor Call
    • Debug exceptions
		Breakpoint Instruction exceptions
		Breakpoint exceptions
		Watchpoint exceptions
		Vector Catch exceptions
		Software Step exceptions
2) Asynchronous exceptions
    • Physical interrupts
        • SError
        • IRQ
        • FIQ
    • Virtual interrupts
        • vSError
        • vIRQ
        • vFIQ

The Exception Syndrome Register, ESR_ELn, contains information which allows the
exception handler to determine the reason for the exception. It is updated only
for synchronous exceptions and SError. It is not updated for IRQ or FIQ as these
interrupt handlers typically obtain status information from registers in the
Generic Interrupt Controller (GIC).

The Arm architecture has two asynchronous exception types, IRQ and FIQ, that are
intended to be used to support handling of peripheral interrupts.

Asynchronous exceptions can be temporarily masked and left in a pending state
until the exception is unmasked and taken.
(Tip: both physical and virtual asynchronous exceptions can be temporarily masked.)

+-------------+        GIC         +---------------------+
| Peripherals | -----------------> | Physical Interrupts |
+-------------+                    +---------------------+

----------------------------------------------------------------------------------------

Virtual interrupts (can be seen by VMs)
    • vSError, Virtual System Error
    • vIRQ, Virtual IRQ
    • vFIQ, Virtual FIQ

Virtual interrupts can be generated either from a hypervisor at EL2 or by using an
interrupt controller. The hypervisor must set the corresponding routing bit in the
Hypervisor Conﬁguration Register (HCR_EL2).

HCR_EL2.VSE -> Setting the bit registers a vSError
HCR_EL2.VI  -> Setting the bit registers a vIRQ
HCR_EL2.VF  -> Setting the bit registers a vFIQ
----------------------------------------------------------------------------------------

In AArch64, interrupts are a specific type of externally generated exception.

@Program Flow in EL0
          |                   Exception Vector Table (VBAR_ELx)
          |                             /
          v       PC -> ELR_EL1        /
          +-------------------------->+
                PSTATE -> SPSR_EL1    |
                                      |
                                      +- Exception Handler
                                      |
                  ELR_EL1 -> PC       |
          +<--------------------------+
          |     SPSR_EL1 -> PSTATE
          |
          v
     [continue]

Saved Program Status Register (SPSR)
	• Condition flags
	• Execution state controls
	• Exception mask bits
	• Access control bits
	• Timing control bits
	• Speculation control bits

Exception mask bits (DAIF) in PSTATE allow exception events to be masked:
    • D - Debug exception mask bit
    • A - SError asynchronous exception mask bit
    • I - IRQ asynchronous exception mask bit
    • F - FIQ asynchronous exception mask bit

For synchronous exceptions and SErrors, the Exception Syndrome Register(ESR) is also
updated.

Each Exception level has its own vector table, with the base address defined by its own
Vector Base Address Register, VBAR_EL<x>, where <x> is 1,2, or 3.

Routing is conﬁgured using the Secure Conﬁguration Register SCR_EL3 and the Hypervisor
Conﬁguration Register HCR_EL2. The SCR_EL3 register speciﬁes which exceptions are
routed to EL3, while the HCR_EL2 register similarly speciﬁes which exceptions are
routed to EL2.

        Exceptions
             |
HCR_EL2 >>---+---> EL2

        Exceptions
             |
SCR_EL3 >>---+---> EL3

----------------------------------------------------------------------------------------

Generic Interrupt Controller (GIC)

The GIC performs the critical tasks of interrupt management, prioritization, and
routing. The GIC marshals all interrupts from across the system, prioritizes them, and
sends them to a core to be dealt with. GICs are primarily used to boost processor
effciency and to enable interrupt virtualization.

[Interrupt Sources] each of them with a unique interrupt ID.
  |  |   ... |
  v  v       v      High
 +-------------+  Priority   +---------------+     IAR     +------------+
 | Distributor | ----------> | CPU Interface | ----------> | CPU core X |
 +-------------+             +---------------+    irqID    +------------+
                                     |                            |
                                     |                            v
                                     |            Device-specific Interrupt Handler
                                     |                            |
                                     |            EoI             v
                                     +<---------------------------+

Types of Interrupts:
	• Software Generated Interrupt (SGI)
	• Private Peripheral Interrupt (PPI)
	• Shared Peripheral Interrupt  (SPI)
	• Locality-specific Peripheral Interrupt (LPI)

Interrupts can either be edge-triggered or level-sensitive.
                             |                   |
        When GIC detets [rising edge] or [high voltage level]

Interrupts can be in different states:
	Inactive
	Pending
	Active
	Active and pending

----------------------------------------------------------------------------------------

Interrupt Handling

The priority and list of cores to which an interrupt can be delivered to are all
configured in the Distributor. An interrupt asserted to the Distributor by a peripheral
is in the Pending state (or Active and Pending if it was already Active).

The Distributor determines the highest priority pending interrupt that can be delivered
to a core and forwards that to the CPU interface of the core. At the CPU interface, the
interrupt is in turn signaled to the core, at which point the core takes the FIQ or IRQ
exception.

When the core takes an interrupt, it jumps to the top-level interrupt vector obtained
from the vector table and begins execution.
The top-level interrupt handler reads the Interrupt Acknowledge Register from the CPU
Interface block to obtain the interrupt ID.

As well as returning the interrupt ID, the read causes the interrupt to be marked as
active in the Distributor. Once the interrupt ID is known (identifying the interrupt
source), the top-level handler can now dispatch a device-specific handler to service
the interrupt.

When the device-specific handler finishes execution, the top-level handler writes the
same interrupt ID to the End of Interrupt (EoI) register in the CPU Interface block,
indicating the end of interrupt processing.
----------------------------------------------------------------------------------------

Reference:
[1] Learn the architecture - AArch64 Exception Model
[2] ARM Cortex-A Series Programmer’s Guide for ARMv8-A
----------------------------------------------------------------------------------------
Reference to Linux-6.1.63

=> linux-6.1.63/arch/arm64/kernel/entry.S

/*
 * Exception vectors.
 */
	.pushsection ".entry.text", "ax"

	.align	11
SYM_CODE_START(vectors)
	kernel_ventry	1, t, 64, sync		// Synchronous EL1t ------+
	kernel_ventry	1, t, 64, irq		// IRQ EL1t               |
	kernel_ventry	1, t, 64, fiq		// FIQ EL1t               | UNHANDLED
	kernel_ventry	1, t, 64, error		// Error EL1t ------------+

	kernel_ventry	1, h, 64, sync		// Synchronous EL1h
	kernel_ventry	1, h, 64, irq		// IRQ EL1h
	kernel_ventry	1, h, 64, fiq		// FIQ EL1h
	kernel_ventry	1, h, 64, error		// Error EL1h

	kernel_ventry	0, t, 64, sync		// Synchronous 64-bit EL0
	kernel_ventry	0, t, 64, irq		// IRQ 64-bit EL0
	kernel_ventry	0, t, 64, fiq		// FIQ 64-bit EL0
	kernel_ventry	0, t, 64, error		// Error 64-bit EL0

	kernel_ventry	0, t, 32, sync		// Synchronous 32-bit EL0
	kernel_ventry	0, t, 32, irq		// IRQ 32-bit EL0
	kernel_ventry	0, t, 32, fiq		// FIQ 32-bit EL0
	kernel_ventry	0, t, 32, error		// Error 32-bit EL0
SYM_CODE_END(vectors)

=> linux-6.1.63/arch/arm64/kernel/entry-common.c
----------------------------------------------------------------------------------------
